<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Ryu Dashboard — Simple Topology & Flows</title>
  <script src="https://unpkg.com/vis-network@9.1.0/dist/vis-network.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 12px; }
    #network { width: 100%; height: 700px; border: 1px solid #ddd; margin-top: 8px; }
    .status { margin-bottom: 8px; }
    .small { font-size: 0.9em; color: #666; }
    button { padding: 6px 12px; font-size: 1em; }
  </style>
</head>
<body>
  <h2>Ryu Dashboard: nodes & flows</h2>
  <div class="status">
    <span id="status">Idle</span>
    <span class="small"> — click "Ping All" to refresh</span>
  </div>
  <button id="pingBtn">Ping All</button>
  <div id="network"></div>

<script>
const API_BASE = "http://127.0.0.1:8080";
let network = null;

function setStatus(txt, ok=true){
  const s = document.getElementById('status');
  s.textContent = txt;
  s.style.color = ok ? 'green' : 'crimson';
}

async function fetchJSON(path, options){
  try {
    const res = await fetch(API_BASE + path, options);
    if(!res.ok) throw new Error(res.status + ' ' + res.statusText);
    return await res.json();
  } catch(e){
    throw e;
  }
}

function buildGraph(data){
  const nodes = [];
  const edges = [];
  const switchMap = {};

  (data.switches || []).forEach(sw => {
    const sid = "SW" + sw.switch;
    switchMap[sw.switch] = sid;
    nodes.push({ id: sid, label: sid, shape: "box", size: 24 });
    const table = sw.learned_table || sw.hosts || {};
    // support both "learned_table" and "hosts" formats
    if (Array.isArray(table)) {
      table.forEach(h => {
        const hid = h.mac;
        if (!nodes.find(n => n.id === hid)) {
          nodes.push({ id: hid, label: hid, shape: "ellipse", size: 18 });
        }
        edges.push({ from: sid, to: hid, label: "port " + h.port, arrows: "to" });
      });
    } else {
      Object.entries(table).forEach(([mac, port]) => {
        const hid = mac;
        if (!nodes.find(n => n.id === hid)) {
          nodes.push({ id: hid, label: hid, shape: "ellipse", size: 18 });
        }
        edges.push({ from: sid, to: hid, label: "port " + port, arrows: "to" });
      });
    }
  });

  (data.installed_flows || []).forEach(f => {
    const srcExists = nodes.find(n => n.id === f.eth_src);
    const dstExists = nodes.find(n => n.id === f.eth_dst);
    if (srcExists && dstExists) {
      edges.push({
        from: f.eth_src,
        to: f.eth_dst,
        arrows: "to",
        dashes: true,
        label: "flow on SW" + f.switch,
        color: { color: '#333' }
      });
    }
  });

  // new: add switch-switch links from topology API
  (data.links || []).forEach(l => {
    const fromId = switchMap[l.src_dpid] || ("SW" + l.src_dpid);
    const toId = switchMap[l.dst_dpid] || ("SW" + l.dst_dpid);
    // add nodes for switches if not present
    if (!nodes.find(n => n.id === fromId)) nodes.push({ id: fromId, label: fromId, shape: "box", size: 24 });
    if (!nodes.find(n => n.id === toId)) nodes.push({ id: toId, label: toId, shape: "box", size: 24 });
    edges.push({
      from: fromId,
      to: toId,
      label: "port " + l.src_port + "→" + l.dst_port,
      color: { color: '#0077cc' },
      arrows: "to"
    });
  });

  return { nodes, edges };
}

function draw(visNodes, visEdges){
  const container = document.getElementById('network');
  const data = {
    nodes: new vis.DataSet(visNodes),
    edges: new vis.DataSet(visEdges)
  };
  const options = {
    physics: { stabilization: true },
    edges: { smooth: { type: "cubicBezier" }, font: { align: "top" } },
    nodes: { font: { size: 12 } }
  };

  if (!network) {
    network = new vis.Network(container, data, options);
  } else {
    network.setData(data);
  }
}

// replaced refresh to request both topology and flows and merge them
async function refresh(){
  try {
    const topo = await fetchJSON("/topology");
    const flows = await fetchJSON("/flows");
    const combined = {
      switches: topo.switches || [],
      links: topo.links || [],
      installed_flows: flows.installed_flows || []
    };
    const g = buildGraph(combined);
    draw(g.nodes, g.edges);
    setStatus("Data loaded");
  } catch (err) {
    setStatus("Error: " + err.message, false);
  }
}

// New function: trigger /pingall and refresh
async function pingAll(){
  setStatus("Pinging all hosts...");
  try {
    // send a POST request to /pingall
    await fetchJSON("/pingall", { method: "POST" });
    // refresh topology & flows after ping completes
    await refresh();
  } catch(err) {
    setStatus("Ping failed: " + err.message, false);
  }
}

// attach event listener to button
document.getElementById("pingBtn").addEventListener("click", pingAll);

// initial load
refresh();
</script>
</body>
</html>
